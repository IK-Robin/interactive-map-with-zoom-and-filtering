<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Interactive SVG Map — Zoom Floor + Full Features</title>
<style>
  :root{
    --bg:#0b0f14; --panel:#0f1621; --ink:#e9eef6; --sub:#a9b4c4;
    --res:#60a5fa; --ret:#fbbf24; --off:#a78bfa; --ind:#f97316; --hos:#f472b6;
    --edu:#22c55e; --hlth:#ef4444; --rec:#2dd4bf; --mix:#c084fc; --infra:#94a3b8;
    --stroke:#18202b; --muted:#223043;
  }
  *{box-sizing:border-box}
  body{margin:0;font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial;color:var(--ink);background:#0b0f14}

  .wrap{max-width:1200px;margin:0 auto}
  .topbar{position:sticky;top:0;z-index:10;background:#0f1621;border-bottom:1px solid var(--stroke)}
  .topbar-inner{display:flex;gap:12px;align-items:center;flex-wrap:wrap;padding:10px 16px}
  .btn{background:#111827;border:1px solid #1f2a38;color:#cfe3ff;padding:6px 10px;border-radius:10px;cursor:pointer}
  .btn:hover{border-color:#2a3a52}
  .btn.ghost{background:transparent}
  .badge{background:#0d1520;border:1px solid #203049;color:#bcd0ea;padding:4px 8px;border-radius:999px}
  .legend{display:flex;gap:10px;row-gap:8px;flex-wrap:wrap}
  .chip{display:flex;gap:6px;align-items:center;border:1px solid #1f2a38;border-radius:999px;padding:4px 8px;cursor:pointer}
  .dot{width:12px;height:12px;border-radius:50%}
  input[type="radio"]{display:none}
  .chip input:checked + .dot{outline:2px solid #ffffff66;outline-offset:2px}

  .layout{display:grid;grid-template-columns:260px 1fr;gap:14px;padding:14px}
  .panel{background:#0f1621;border:1px solid var(--stroke);border-radius:14px;padding:14px;box-shadow:0 10px 40px rgba(0,0,0,.28)}
  .sidebar .title{margin:0 0 8px;font-size:16px}
  .list{list-style:none;padding:0;margin:0;display:grid;gap:6px}
  .list .btn{width:100%;text-align:left;display:flex;justify-content:space-between;align-items:center}
  .small-badge{font-size:11px;padding:2px 8px;border-radius:999px;border:1px solid #203049;background:#0d1520;color:#bcd0ea}
  .node-has-matches{border-color:#2b3b54;background:#0d1726}
  .node-has-matches .small-badge{display:inline-block}
  .small-badge.hidden{display:none}

  .mapWrap{position:relative}
  svg{width:100%;height:auto;display:block;background:#0a121b;border-radius:12px;border:1px solid #17212f;touch-action:none}
  .nodes text{font-size:18px;fill:#cfd8e3;font-weight:600;cursor:pointer}
  .node{fill:#0e1a29;stroke:#1d2a3b;stroke-width:2;cursor:pointer}
  .node:hover,.is-hot{filter:drop-shadow(0 0 8px rgba(125,211,252,.5))}
  .parcel{stroke:#0e1622;stroke-width:2;vector-effect:non-scaling-stroke;cursor:pointer}

  .summary-bottom{position:absolute;left:50%;transform:translateX(-50%);bottom:12px;background:#0d1420;border:1px solid #223043;padding:10px 14px;border-radius:12px;box-shadow:0 12px 40px rgba(0,0,0,.35);z-index:3}
  .counter{position:absolute;left:50%;transform:translateX(-50%);bottom:62px;background:#0d1420;border:1px solid #223043;padding:8px 12px;border-radius:999px;z-index:3}
  .node-title{position:absolute;left:12px;top:12px;background:#0d1420;border:1px solid #223043;padding:8px 10px;border-radius:10px;z-index:3}

  .tooltip{position:fixed;pointer-events:none;max-width:260px;background:#0d1420;border:1px solid #223043;padding:8px 10px;border-radius:10px;box-shadow:0 20px 60px rgba(0,0,0,.45);z-index:4;font-size:12px}
  .popover{position:fixed;max-width:360px;background:#0d1420;border:1px solid #223043;padding:12px;border-radius:12px;box-shadow:0 20px 60px rgba(0,0,0,.45);z-index:5}
  .hidden{display:none}

  .btn.match { font-weight:700; border-color:transparent; }
  .btn.dim { opacity:.45; }

  .ov-parcel, .ov-parcel * { pointer-events:none !important; }
  .disabled { pointer-events:none !important; }

  .c-Residential{fill:var(--res)} .c-Retail{fill:var(--ret)} .c-Office{fill:var(--off)}
  .c-Industrial{fill:var(--ind)} .c-Hospitality{fill:var(--hos)} .c-Educational{fill:var(--edu)}
  .c-Health{fill:var(--hlth)} .c-Recreational{fill:var(--rec)} .c-Mixed{fill:var(--mix)} .c-Infrastructure{fill:var(--infra)}
</style>
</head>
<body>
<div class="wrap">

  <div class="topbar">
    <div class="topbar-inner">
      <button id="backBtn" class="btn ghost" disabled>← Back to all nodes</button>
      <button id="zoomInBtn" class="btn">＋</button>
      <button id="zoomOutBtn" class="btn">－</button>
      <button id="resetBtn" class="btn">Reset view</button>
      <span id="status" class="badge">No filter</span>
      <div id="legend" class="legend" role="radiogroup" aria-label="Development Type Selection"></div>
      <button id="clearType" class="btn ghost">Clear filter</button>
    </div>
  </div>

  <div class="layout">
    <aside class="panel sidebar">
      <h3 id="nodesTitle" class="title">Nodes</h3>
      <ul id="nodeList" class="list"></ul>
      <div id="nodesDivider" style="height:1px;background:linear-gradient(90deg,transparent,#223043,transparent);margin:12px 0"></div>
      <h3 class="title">Parcels</h3>
      <ul id="parcelList" class="list"></ul>
    </aside>

    <div class="panel mapWrap">
      <div id="nodeTitle" class="node-title hidden"></div>
      <svg id="map" viewBox="0 0 1200 720" aria-label="Development map">
        <rect x="0" y="0" width="1200" height="720" fill="#0a121b"/>
        <g id="stage">
          <g id="nodeLayer" class="nodes"></g>
          <g id="parcelLayer"></g>
        </g>
      </svg>

      <div id="counter" class="counter hidden"></div>
      <div id="summaryBottom" class="summary-bottom hidden" aria-live="polite"></div>

      <div id="tooltip" class="tooltip hidden"></div>
      <div id="popover" class="popover hidden" role="dialog" aria-modal="true"></div>
    </div>
  </div>
</div>

<script>
/* --------------------------- Demo Data (replace) --------------------------- */
const NODES = [
  {id:'node1', name:'Node One', path:'M80,120 L360,90 L400,220 L140,260 Z', info:{area:52.4, parcels:18}},
  {id:'node2', name:'Node Two', path:'M430,80 L700,120 L640,260 L420,220 Z', info:{area:64.1, parcels:22}},
  {id:'node3', name:'Node Three', path:'M760,100 L1080,120 L1060,300 L840,260 Z', info:{area:48.3, parcels:16}},
  {id:'node4', name:'Node Four', path:'M200,380 L520,360 L540,600 L220,560 Z', info:{area:71.2, parcels:26}},
  {id:'node5', name:'Node Five', path:'M680,360 L1080,380 L1060,620 L720,580 Z', info:{area:58.6, parcels:21}},
];
const PARCELS = {
  node1:[
    {id:'1A', path:'M120,140 L220,130 L220,210 L140,220 Z', type:'Retail', area:1.6, status:'Available'},
    {id:'1B', path:'M230,120 L340,110 L350,180 L240,200 Z', type:'Residential', area:2.1, status:'Reserved'},
    {id:'1C', path:'M155,225 L275,210 L275,245 L165,255 Z', type:'Office', area:1.1, status:'Available'}
  ],
  node2:[
    {id:'2A', path:'M460,140 L560,150 L550,220 L460,210 Z', type:'Industrial', area:3.6, status:'Available'},
    {id:'2B', path:'M565,150 L650,160 L635,230 L555,220 Z', type:'Retail', area:2.4, status:'Sold'},
    {id:'2C', path:'M470,225 L600,240 L600,255 L470,245 Z', type:'Residential', area:1.8, status:'Available'}
  ],
  node3:[
    {id:'3A', path:'M800,160 L940,160 L930,230 L810,220 Z', type:'Hospitality', area:2.2, status:'Available'},
    {id:'3B', path:'M950,160 L1040,170 L1030,250 L940,240 Z', type:'Retail', area:2.0, status:'Available'}
  ],
  node4:[
    {id:'4A', path:'M240,400 L360,395 L360,470 L250,480 Z', type:'Educational', area:1.4, status:'Available'},
    {id:'4B', path:'M370,392 L500,388 L510,520 L380,520 Z', type:'Residential', area:4.6, status:'Available'},
    {id:'4C', path:'M240,490 L520,480 L525,560 L250,565 Z', type:'Recreational', area:3.0, status:'Available'}
  ],
  node5:[
    {id:'5A', path:'M720,395 L830,400 L820,500 L730,495 Z', type:'Mixed', area:2.8, status:'Available'},
    {id:'5B', path:'M835,402 L980,410 L970,520 L830,510 Z', type:'Health', area:3.2, status:'Available'},
    {id:'5C', path:'M740,520 L1040,540 L1035,600 L750,585 Z', type:'Infrastructure', area:2.1, status:'N/A'}
  ]
};

/* ------------------------------ Setup refs -------------------------------- */
const TYPE_COLORS = {
  Residential:'var(--res)', Retail:'var(--ret)', Office:'var(--off)', Industrial:'var(--ind)',
  Hospitality:'var(--hos)', Educational:'var(--edu)', Health:'var(--hlth)', Recreational:'var(--rec)',
  Mixed:'var(--mix)', Infrastructure:'var(--infra)'
};
const TYPE_CLASS = Object.fromEntries(Object.keys(TYPE_COLORS).map(k=>[k,'c-'+k]));

const map = document.getElementById('map');
const stage = document.getElementById('stage');
const nodeLayer = document.getElementById('nodeLayer');
const parcelLayer = document.getElementById('parcelLayer');
const nodeList = document.getElementById('nodeList');
const parcelList = document.getElementById('parcelList');
const tooltip = document.getElementById('tooltip');
const popover = document.getElementById('popover');
const statusEl = document.getElementById('status');
const counter = document.getElementById('counter');
const summaryBottom = document.getElementById('summaryBottom');
const nodeTitle = document.getElementById('nodeTitle');

const nodesTitle = document.getElementById('nodesTitle');
const nodesDivider = document.getElementById('nodesDivider');

const backBtn = document.getElementById('backBtn');
const zoomInBtn = document.getElementById('zoomInBtn');
const zoomOutBtn = document.getElementById('zoomOutBtn');
const resetBtn = document.getElementById('resetBtn');
const legend = document.getElementById('legend');
const clearType = document.getElementById('clearType');

let currentNode = null;
let currentType = null;

/* ---------------------------- Transform state ----------------------------- */
let t = {x:0,y:0,scale:1};               // current
let base = {x:0,y:0,scale:1};            // minimum zoom-out (reset floor)

function setBaseTransform(tf){ base = {...tf}; }
function applyTransform(){ stage.setAttribute('transform', `translate(${t.x},${t.y}) scale(${t.scale})`); }

/* ------------------------------- Legend UI -------------------------------- */
Object.entries(TYPE_COLORS).forEach(([label,color])=>{
  const wrap = document.createElement('label'); wrap.className='chip';
  wrap.innerHTML = `<input type="radio" name="type" value="${label}"><span class="dot" style="background:${color}"></span>${label}`;
  wrap.querySelector('input').addEventListener('change',()=>setType(label));
  legend.appendChild(wrap);
});
clearType.addEventListener('click', ()=>setType(null));

/* ------------------------------ Utilities --------------------------------- */
function elem(tag, attrs={}, text){
  const e = document.createElementNS('http://www.w3.org/2000/svg', tag);
  Object.entries(attrs).forEach(([k,v])=>e.setAttribute(k,v));
  if(text) e.appendChild(document.createTextNode(text));
  return e;
}
function centroid(pathD){
  const p = elem('path',{d:pathD}); stage.appendChild(p);
  const bb = p.getBBox(); p.remove();
  return {x: bb.x + bb.width/2, y: bb.y + bb.height/2};
}
function pathBBox(pathD){
  const p = elem('path',{d:pathD}); stage.appendChild(p);
  const bb = p.getBBox(); p.remove();
  return bb;
}
function svgToClient(x,y){
  const pt = map.createSVGPoint(); pt.x=x; pt.y=y;
  const screen = pt.matrixTransform(stage.getCTM()).matrixTransform(map.getScreenCTM());
  return {x:screen.x, y:screen.y};
}
function unionBBox(bbs){
  const xs=bbs.map(b=>b.x), ys=bbs.map(b=>b.y), x2s=bbs.map(b=>b.x+b.width), y2s=bbs.map(b=>b.y+b.height);
  const x=Math.min(...xs), y=Math.min(...ys), x2=Math.max(...x2s), y2=Math.max(...y2s);
  return {x, y, width:x2-x, height:y2-y};
}

/* --------------------------- Tooltip & Popover ---------------------------- */
function showTooltipAt(x,y,html){
  tooltip.innerHTML = html;
  tooltip.classList.remove('hidden');
  const r = tooltip.getBoundingClientRect();
  let left = x + 12, top = y + 12, m = 8;
  if(left + r.width > innerWidth - m) left = innerWidth - r.width - m;
  if(top + r.height > innerHeight - m) top = innerHeight - r.height - m;
  tooltip.style.left = left + 'px';
  tooltip.style.top = top + 'px';
}
function hideTooltip(){ tooltip.classList.add('hidden'); }

let activePopover = { followEl: null };
function setPopoverContent(html){ popover.innerHTML = html; popover.classList.remove('hidden'); }
function positionPopoverAtClient(x, y){
  const r = popover.getBoundingClientRect();
  let left = x + 12, top = y + 12, m = 8;
  if(left + r.width > innerWidth - m) left = innerWidth - r.width - m;
  if(top + r.height > innerHeight - m) top = innerHeight - r.height - m;
  if(left < m) left = m; if(top < m) top = m;
  popover.style.left = left + 'px';
  popover.style.top = top + 'px';
}
function positionPopoverForElement(el, anchor = 'top-center'){
  const bb = el.getBBox();
  const ax = bb.x + bb.width/2;
  const ay = (anchor === 'top-center') ? bb.y : (bb.y + bb.height/2);
  const pt = svgToClient(ax, ay);
  positionPopoverAtClient(pt.x, pt.y);
}
function startPopoverFollow(el){ activePopover.followEl = el; }
function stopPopoverFollow(){ activePopover.followEl = null; }
window.addEventListener('pointerdown', e=>{ if(!popover.contains(e.target)) popover.classList.add('hidden'); });

/* ------------------------------ Zoom & Pan -------------------------------- */
function animateTo(target, ms = 280, onUpdate = null, onDone = null){
  const start = {...t}; const dtX = target.x - start.x, dtY = target.y - start.y, dtS = target.scale - start.scale;
  const t0 = performance.now();
  function step(now){
    const p = Math.min(Math.max((now - t0)/ms, 0), 1);
    const ease = p < .5 ? 2*p*p : 1 - Math.pow(-2*p+2,2)/2;
    t = { x: start.x + dtX*ease, y: start.y + dtY*ease, scale: start.scale + dtS*ease };
    applyTransform();
    if (onUpdate) onUpdate(ease);
    if (p < 1) requestAnimationFrame(step);
    else if (onDone) onDone();
  }
  requestAnimationFrame(step);
}

function computeFitTransform(bb, padding = 24){
  const svgW=1200, svgH=720;
  const scale = Math.min(svgW/(bb.width+padding*2), svgH/(bb.height+padding*2));
  const cx = bb.x + bb.width/2, cy = bb.y + bb.height/2;
  const x = svgW/2 - scale*cx, y = svgH/2 - scale*cy;
  return {x,y,scale};
}

function zoomToBBox(bb, padding = 24, followEl = null, setAsBase = false){
  const target = computeFitTransform(bb, padding);

  if (followEl) startPopoverFollow(followEl);
  animateTo(target, 320,
    () => { if (activePopover.followEl) positionPopoverForElement(activePopover.followEl, 'top-center'); },
    () => { stopPopoverFollow(); }
  );

  if (setAsBase) setBaseTransform(target);
}

function zoomBy(factor, centerX=600, centerY=360){
  // proposed scale
  let newScale = Math.max(base.scale, Math.min(12, t.scale*factor));
  // If trying to go below base, snap to base transform exactly
  if (newScale === base.scale && factor < 1){
    t = {...base};
    applyTransform();
    return;
  }
  // normal zoom around pointer (with floor)
  t.x = centerX - (centerX - t.x) * (newScale / t.scale);
  t.y = centerY - (centerY - t.y) * (newScale / t.scale);
  t.scale = newScale; 
  applyTransform();
}

/* --------- Smart fit helpers (initial / Reset / Back) --------------------- */
function fitOverview(setBase=true){
  const bbs = NODES.map(n => pathBBox(n.path));
  const bb = unionBBox(bbs);
  zoomToBBox(bb, 36, null, setBase);  // setAsBase true on initial/back/reset
}
function fitCurrentNode(setBase=true){
  const list = PARCELS[currentNode] || [];
  if (!list.length){
    const target = {x:0,y:0,scale:1};
    animateTo(target); 
    if (setBase) setBaseTransform(target);
    return;
  }
  const bbs = list.map(p => pathBBox(p.path));
  const bb = unionBBox(bbs);
  zoomToBBox(bb, 36, null, setBase);  // setAsBase true on enter/reset
}

zoomInBtn.addEventListener('click', ()=>zoomBy(1.25));
zoomOutBtn.addEventListener('click', ()=>zoomBy(0.8));
resetBtn.addEventListener('click', ()=>{
  tooltip.classList.add('hidden'); popover.classList.add('hidden'); stopPopoverFollow();
  if (currentNode) fitCurrentNode(true); else fitOverview(true); // reset sets base
});

// Wheel zoom (pointer-centered with floor)
map.addEventListener('wheel', (e)=>{
  e.preventDefault();
  const rect = map.getBoundingClientRect();
  zoomBy(e.deltaY<0?1.1:0.9, e.clientX - rect.left, e.clientY - rect.top);
}, {passive:false});

// Drag & Pan with threshold
const PAN_THRESHOLD = 6;
let pan = {tracking:false, panning:false, id:null, startX:0, startY:0, lastX:0, lastY:0};
let justDragged = false;

map.addEventListener('pointerdown', (e)=>{
  pan.tracking = true; pan.panning = false;
  pan.id = e.pointerId; pan.startX = pan.lastX = e.clientX; pan.startY = pan.lastY = e.clientY;
  const isBackground = (e.target === map || e.target.tagName === 'rect');
  if (isBackground){ pan.panning = true; map.setPointerCapture(pan.id); }
});
map.addEventListener('pointermove', (e)=>{
  if(!pan.tracking) return;
  if(!pan.panning){
    const dx0 = e.clientX - pan.startX, dy0 = e.clientY - pan.startY;
    if(Math.hypot(dx0,dy0) >= PAN_THRESHOLD){ pan.panning = true; justDragged = true; map.setPointerCapture(pan.id); }
    else return;
  }
  const dx = e.clientX - pan.lastX, dy = e.clientY - pan.lastY;
  pan.lastX = e.clientX; pan.lastY = e.clientY;
  t.x += dx; t.y += dy; applyTransform();
});
map.addEventListener('pointerup', ()=>{
  if(pan.panning) map.releasePointerCapture(pan.id);
  pan = {tracking:false, panning:false, id:null, startX:0, startY:0, lastX:0, lastY:0};
  if(justDragged) setTimeout(()=>{ justDragged=false; }, 0);
});

/* ------------------------------- Rendering -------------------------------- */
function labelTopCenterClient(pathD){
  const p = elem('path',{d:pathD}); stage.appendChild(p);
  const bb = p.getBBox(); p.remove();
  return svgToClient(bb.x+bb.width/2, bb.y);
}

function drawNodes(){
  nodeLayer.innerHTML='';
  NODES.forEach(n=>{
    const g = elem('g',{class:'nodeGroup'});
    const path = elem('path',{d:n.path,class:'node',tabindex:0});
    path.addEventListener('pointermove', e=>{
      const extra = currentType ? `<br><small>${countTypeInNode(n.id,currentType)} ${currentType} available</small>` : '';
      showTooltipAt(e.clientX, e.clientY, `<b>${n.name}</b><br><small>Area: ${n.info.area} ha • Parcels: ${n.info.parcels}</small>${extra}`);
    });
    path.addEventListener('pointerleave', ()=>tooltip.classList.add('hidden'));
    path.addEventListener('click', ()=>{ if(!justDragged) enterNode(n.id); });
    g.appendChild(path);

    const c = centroid(n.path);
    const label = elem('text',{x:c.x,y:c.y,'text-anchor':'middle','dominant-baseline':'middle'}, n.name);
    label.addEventListener('pointermove', ()=>{
      const pt = labelTopCenterClient(n.path);
      const extra = currentType ? `<br><small>${countTypeInNode(n.id,currentType)} ${currentType} available</small>` : '';
      showTooltipAt(pt.x, pt.y, `<b>${n.name}</b><br><small>Area: ${n.info.area} ha • Parcels: ${n.info.parcels}</small>${extra}`);
    });
    label.addEventListener('pointerleave', ()=>tooltip.classList.add('hidden'));
    label.addEventListener('click', ()=>{ if(!justDragged) enterNode(n.id); });
    g.appendChild(label);

    nodeLayer.appendChild(g);
  });
}

function drawParcelsOverview(){
  parcelLayer.innerHTML='';
  if(!currentType) return;
  Object.entries(PARCELS).forEach(([nodeId,list])=>{
    list.filter(p=>p.type===currentType).forEach(p=>{
      const path = elem('path',{d:p.path,class:`parcel ov-parcel ${TYPE_CLASS[p.type]}`});
      path.setAttribute('fill-opacity','0.75');
      parcelLayer.appendChild(path);
    });
  });
}

/* ------------------------------- Sidebar ---------------------------------- */
function buildNodeList(){
  nodeList.innerHTML='';

  if (NODES.length > 1){
    const li0 = document.createElement('li');
    const btn0 = document.createElement('button'); btn0.className='btn'; btn0.textContent='Overview (All Nodes)';
    btn0.addEventListener('click', ()=>exitToOverview());
    li0.appendChild(btn0); nodeList.appendChild(li0);
  }

  NODES.forEach(n=>{
    const li = document.createElement('li');
    const btn = document.createElement('button'); btn.className='btn node-btn'; btn.dataset.nodeId = n.id;
    btn.innerHTML = `<span>${n.name}</span><span class="small-badge hidden">0</span>`;
    btn.addEventListener('mouseenter', ()=>{
      const pt = labelTopCenterClient(n.path);
      const extra = currentType ? `<br><small>${countTypeInNode(n.id,currentType)} ${currentType} available</small>` : '';
      showTooltipAt(pt.x, pt.y, `<b>${n.name}</b><br><small>Area: ${n.info.area} ha • Parcels: ${n.info.parcels}</small>${extra}`);
      nodeLayer.querySelectorAll('path').forEach(p=>p.classList.remove('is-hot'));
      const nodePath = [...nodeLayer.querySelectorAll('path')].find(p=>p.getAttribute('d')===n.path);
      if(nodePath) nodePath.classList.add('is-hot');
    });
    btn.addEventListener('mouseleave', ()=>{ tooltip.classList.add('hidden'); nodeLayer.querySelectorAll('path').forEach(p=>p.classList.remove('is-hot')); });
    btn.addEventListener('click', ()=>enterNode(n.id));
    li.appendChild(btn); nodeList.appendChild(li);
  });

  updateNodeListHighlight();
}

function buildParcelList(){
  parcelList.innerHTML='';
  if(!currentNode) return;

  const list = PARCELS[currentNode] || [];
  list.forEach(p=>{
    const li = document.createElement('li');
    const btn = document.createElement('button');
    btn.className='btn';
    btn.style.width='100%';
    btn.style.textAlign='left';
    btn.textContent = `Parcel ${p.id} — ${p.type}`;

    const isMatch = !!currentType && p.type === currentType && (p.status || '').toLowerCase() === 'available';
    if (currentType) {
      if (isMatch) {
        btn.classList.add('match');
        btn.style.background = TYPE_COLORS[p.type] || '#334155';
        btn.style.color = '#0b0f14';
      } else {
        btn.classList.add('dim');
      }
    }

    btn.addEventListener('mouseenter', ()=>{
      const tmp = elem('path',{d:p.path}); stage.appendChild(tmp); const bb = tmp.getBBox(); tmp.remove();
      const pt = svgToClient(bb.x+bb.width/2, bb.y);
      showTooltipAt(pt.x, pt.y, `<b>Parcel ${p.id}</b><br><small>${p.type} • ${p.area.toFixed(1)} ha</small>`);
    });
    btn.addEventListener('mouseleave', ()=>tooltip.classList.add('hidden'));

    btn.addEventListener('click', ()=>{
      const el = [...parcelLayer.querySelectorAll('path')].find(q => q.getAttribute('d') === p.path);
      if(el){
        openParcelPanel({ currentTarget: el }, p, currentNode);
        const bb = el.getBBox();
        zoomToBBox(bb, 24, el); // follow; base unchanged (detail zoom)
      }
    });

    li.appendChild(btn);
    parcelList.appendChild(li);
  });
}

/* ----------------------------- Interactions -------------------------------- */
function countTypeInNode(nodeId, type){
  return (PARCELS[nodeId]||[]).filter(p=>p.type===type).length;
}

function updateNodeListHighlight(){
  const items = nodeList.querySelectorAll('.node-btn');
  items.forEach(btn=>{
    const id = btn.dataset.nodeId;
    const badge = btn.querySelector('.small-badge');
    if(!currentType){
      btn.classList.remove('node-has-matches'); badge.classList.add('hidden'); badge.textContent='0';
      return;
    }
    const n = countTypeInNode(id, currentType);
    if(n>0){ btn.classList.add('node-has-matches'); badge.classList.remove('hidden'); badge.textContent = n; }
    else { btn.classList.remove('node-has-matches'); badge.classList.add('hidden'); badge.textContent='0'; }
  });
}

function setType(tLabel){
  currentType = tLabel;
  statusEl.textContent = tLabel ? `Filtering: ${tLabel}` : 'No filter';
  updateSummary();
  redraw();
  buildParcelList();
  updateNodeListHighlight();
}

function openParcelPanel(evt, p, nodeId){
  const el = evt.currentTarget;
  setPopoverContent(`
    <h3 style="margin:0 0 6px">Parcel ${p.id} — ${p.type}</h3>
    <div><b>Area:</b> ${p.area.toFixed(1)} ha</div>
    <div><b>Status:</b> ${p.status||'—'}</div>
    <div><b>Utilities:</b> Power, Water (demo)</div>
    <div><b>Zoning:</b> ${p.type} (demo)</div>
    <div style="display:flex;gap:8px;margin-top:8px">
      <button class="btn">Download PDF</button>
      <button class="btn">View Development Potential</button>
    </div>
  `);
  positionPopoverForElement(el, 'top-center');
  startPopoverFollow(el);
}

function enterNode(id){
  currentNode = id;
  updateBackState(); tooltip.classList.add('hidden'); popover.classList.add('hidden'); stopPopoverFollow();

  nodeLayer.innerHTML='';
  nodeTitle.classList.remove('hidden');
  nodeTitle.textContent = `${NODES.find(n=>n.id===id).name} — Parcels`;

  parcelLayer.innerHTML='';
  const list = PARCELS[id]||[];
  list.forEach(p=>{
    const isMatch = !currentType || p.type === currentType;
    const path = elem('path',{d:p.path,class:`parcel ${TYPE_CLASS[p.type]}`});
    path.style.opacity = isMatch ? .95 : .18;

    if (!isMatch) {
      path.classList.add('disabled');
    } else {
      path.addEventListener('pointermove', e=>{
        showTooltipAt(e.clientX, e.clientY, `<b>Parcel ${p.id}</b><br><small>${p.type} • ${p.area.toFixed(1)} ha</small>`);
      });
      path.addEventListener('pointerleave', ()=>tooltip.classList.add('hidden'));
      path.addEventListener('click', e=>{
        if(justDragged) return;
        e.stopPropagation();
        openParcelPanel(e, p, id);
        zoomToBBox(path.getBBox(), 24, path); // detail zoom; base unchanged
      });
    }
    parcelLayer.appendChild(path);
  });

  buildParcelList();
  fitCurrentNode(true);           // <- fit and set base to node
  summaryBottom.classList.add('hidden');
  updateNodeListHighlight();
}

function exitToOverview(){
  currentNode = null;
  updateBackState(); tooltip.classList.add('hidden'); popover.classList.add('hidden'); stopPopoverFollow();

  nodeTitle.classList.add('hidden');
  parcelLayer.innerHTML='';
  drawNodes(); drawParcelsOverview();
  buildParcelList();
  updateSummary();
  fitOverview(true);              // <- fit and set base to overview
  updateNodeListHighlight();
}

backBtn.addEventListener('click', exitToOverview);

map.addEventListener('click', (e)=>{
  if(e.target === map || e.target.tagName === 'rect'){ tooltip.classList.add('hidden'); popover.classList.add('hidden'); stopPopoverFollow(); }
});
window.addEventListener('keydown', e=>{ if(e.key==='Escape' && currentNode){ exitToOverview(); } });

function updateBackState(){
  const single = NODES.length <= 1;
  backBtn.disabled = single || !currentNode;
}

/* ----------------------- Sidebar visibility (single-node) ------------------ */
function updateSidebarVisibility(){
  const single = NODES.length <= 1;
  nodesTitle.style.display = single ? 'none' : '';
  nodeList.style.display = single ? 'none' : '';
  nodesDivider.style.display = single ? 'none' : '';
}

/* --------------------------- Summary & Counter ----------------------------- */
function getStats(){
  let list = currentNode ? (PARCELS[currentNode]||[]) : Object.values(PARCELS).flat();
  if(currentType) list = list.filter(p=>p.type===currentType);
  const area = list.reduce((s,p)=>s+(p.area||0),0);
  return {count:list.length, area};
}
function updateSummary(){
  const stats = getStats();
  const title = currentNode ? `${NODES.find(n=>n.id===currentNode).name}` : 'Summary — Overview';
  const ttype = currentType || 'All Types';

  if(!currentNode){
    summaryBottom.classList.remove('hidden');
    summaryBottom.innerHTML = `<b>${title}</b> · Type: ${ttype} · Parcels: ${stats.count} · Total Area: ${stats.area.toFixed(1)} ha`;
  } else {
    summaryBottom.classList.add('hidden');
  }

  if(currentType){
    counter.textContent = `${stats.count} ${currentType} Parcels Available`;
    counter.classList.remove('hidden');
  } else {
    counter.classList.add('hidden');
  }
}

/* --------------------------------- Boot ----------------------------------- */
function redraw(){
  if(currentNode) enterNode(currentNode);
  else { drawNodes(); drawParcelsOverview(); }
}

(function build(){
  buildNodeList();
  updateSidebarVisibility();
  updateBackState();

  if (NODES.length === 1){
    enterNode(NODES[0].id);     // single-node mode; base set in fitCurrentNode(true)
  } else {
    drawNodes();
    drawParcelsOverview();
    updateSummary();
    fitOverview(true);          // sets base to overview fit at load
  }
})();
</script>
</body>
</html>
