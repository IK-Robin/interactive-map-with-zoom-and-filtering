<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Interactive SVG Map – Follow Popover, Clickable Everything</title>
<style>
  :root{
    --bg:#0b0f14; --panel:#0f1621; --ink:#e9eef6; --sub:#a9b4c4; --muted:#223043;
    --res:#60a5fa; --ret:#fbbf24; --off:#a78bfa; --ind:#f97316; --hos:#f472b6;
    --edu:#22c55e; --hlth:#ef4444; --rec:#2dd4bf; --mix:#c084fc; --infra:#94a3b8;
  }
  *{box-sizing:border-box}
  body{margin:0;font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial;color:var(--ink);background:#0b0f14}

  .wrap{max-width:1200px;margin:0 auto}
  .topbar{position:sticky;top:0;z-index:10;background:#0f1621;border-bottom:1px solid #18202b}
  .topbar-inner{display:flex;gap:12px;align-items:center;flex-wrap:wrap;padding:10px 16px}
  .btn{background:#111827;border:1px solid #1f2a38;color:#cfe3ff;padding:6px 10px;border-radius:10px;cursor:pointer}
  .btn:hover{border-color:#2a3a52}
  .btn.ghost{background:transparent}
  .badge{background:#0d1520;border:1px solid #203049;color:#bcd0ea;padding:4px 8px;border-radius:999px}
  .legend{display:flex;gap:10px;row-gap:8px;flex-wrap:wrap}
  .chip{display:flex;gap:6px;align-items:center;border:1px solid #1f2a38;border-radius:999px;padding:4px 8px;cursor:pointer}
  .dot{width:12px;height:12px;border-radius:50%}
  input[type="radio"]{display:none}
  .chip input:checked + .dot{outline:2px solid #ffffff66;outline-offset:2px}

  .layout{display:grid;grid-template-columns:260px 1fr;gap:14px;padding:14px}
  .panel{background:#0f1621;border:1px solid #18202b;border-radius:14px;padding:14px;box-shadow:0 10px 40px rgba(0,0,0,.28)}
  .sidebar .title{margin:0 0 8px;font-size:16px}
  .list{list-style:none;padding:0;margin:0;display:grid;gap:6px}
  .list .btn{width:100%;text-align:left}

  .mapWrap{position:relative}
  svg{width:100%;height:auto;display:block;background:#0a121b;border-radius:12px;border:1px solid #17212f;touch-action:none}
  .nodes text{font-size:18px;fill:#cfd8e3;font-weight:600;cursor:pointer}
  .node{fill:#0e1a29;stroke:#1d2a3b;stroke-width:2;cursor:pointer}
  .node:hover,.is-hot{filter:drop-shadow(0 0 8px rgba(125,211,252,.5))}
  .parcel{stroke:#0e1622;stroke-width:2;vector-effect:non-scaling-stroke;cursor:pointer}

  .summary-bottom{position:absolute;left:50%;transform:translateX(-50%);bottom:12px;background:#0d1420;border:1px solid #223043;padding:10px 14px;border-radius:12px;box-shadow:0 12px 40px rgba(0,0,0,.35);z-index:3}
  .counter{position:absolute;left:50%;transform:translateX(-50%);bottom:62px;background:#0d1420;border:1px solid #223043;padding:8px 12px;border-radius:999px;z-index:3}
  .node-title{position:absolute;left:12px;top:12px;background:#0d1420;border:1px solid #223043;padding:8px 10px;border-radius:10px;z-index:3}

  .tooltip{position:fixed;pointer-events:none;max-width:260px;background:#0d1420;border:1px solid #223043;padding:8px 10px;border-radius:10px;box-shadow:0 20px 60px rgba(0,0,0,.45);z-index:4;font-size:12px}
  .popover{position:fixed;max-width:360px;background:#0d1420;border:1px solid #223043;padding:12px;border-radius:12px;box-shadow:0 20px 60px rgba(0,0,0,.45);z-index:5}
  .hidden{display:none}

  /* sidebar filter highlighting */
  .btn.match { font-weight:700; border-color:transparent; }
  .btn.dim { opacity:.45; }

  .c-Residential{fill:var(--res)} .c-Retail{fill:var(--ret)} .c-Office{fill:var(--off)}
  .c-Industrial{fill:var(--ind)} .c-Hospitality{fill:var(--hos)} .c-Educational{fill:var(--edu)}
  .c-Health{fill:var(--hlth)} .c-Recreational{fill:var(--rec)} .c-Mixed{fill:var(--mix)} .c-Infrastructure{fill:var(--infra)}
</style>
</head>
<body>
<div class="wrap">

  <div class="topbar">
    <div class="topbar-inner">
      <button id="backBtn" class="btn ghost" disabled>← Back to all nodes</button>
      <button id="zoomInBtn" class="btn">＋</button>
      <button id="zoomOutBtn" class="btn">－</button>
      <button id="resetBtn" class="btn">Reset view</button>
      <span id="status" class="badge">No filter</span>
      <div id="legend" class="legend" role="radiogroup" aria-label="Development Type Selection"></div>
      <button id="clearType" class="btn ghost">Clear filter</button>
    </div>
  </div>

  <div class="layout">
    <aside class="panel sidebar">
      <h3 class="title">Nodes</h3>
      <ul id="nodeList" class="list"></ul>
      <div style="height:1px;background:linear-gradient(90deg,transparent,#223043,transparent);margin:12px 0"></div>
      <h3 class="title">Parcels</h3>
      <ul id="parcelList" class="list"></ul>
    </aside>

    <div class="panel mapWrap">
      <div id="nodeTitle" class="node-title hidden"></div>
      <svg id="map" viewBox="0 0 1200 720" aria-label="Development map">
        <rect x="0" y="0" width="1200" height="720" fill="#0a121b"/>
        <g id="stage">
          <g id="nodeLayer" class="nodes"></g>
          <g id="parcelLayer"></g>
        </g>
      </svg>

      <div id="counter" class="counter hidden"></div>
      <div id="summaryBottom" class="summary-bottom hidden" aria-live="polite"></div>

      <div id="tooltip" class="tooltip hidden"></div>
      <div id="popover" class="popover hidden" role="dialog" aria-modal="true"></div>
    </div>
  </div>
</div>

<script>
/* --------------------------- Demo Data (replace) --------------------------- */
const NODES = [
  {id:'node1', name:'Node One', path:'M80,120 L360,90 L400,220 L140,260 Z', info:{area:52.4, parcels:18}},
  {id:'node2', name:'Node Two', path:'M430,80 L700,120 L640,260 L420,220 Z', info:{area:64.1, parcels:22}},
  {id:'node3', name:'Node Three', path:'M760,100 L1080,120 L1060,300 L840,260 Z', info:{area:48.3, parcels:16}},
  {id:'node4', name:'Node Four', path:'M200,380 L520,360 L540,600 L220,560 Z', info:{area:71.2, parcels:26}},
  {id:'node5', name:'Node Five', path:'M680,360 L1080,380 L1060,620 L720,580 Z', info:{area:58.6, parcels:21}},
];
const PARCELS = {
  node1:[
    {id:'1A', path:'M120,140 L220,130 L220,210 L140,220 Z', type:'Retail', area:1.6, status:'Available'},
    {id:'1B', path:'M230,120 L340,110 L350,180 L240,200 Z', type:'Residential', area:2.1, status:'Reserved'},
    {id:'1C', path:'M155,225 L275,210 L275,245 L165,255 Z', type:'Office', area:1.1, status:'Available'}
  ],
  node2:[
    {id:'2A', path:'M460,140 L560,150 L550,220 L460,210 Z', type:'Industrial', area:3.6, status:'Available'},
    {id:'2B', path:'M565,150 L650,160 L635,230 L555,220 Z', type:'Retail', area:2.4, status:'Sold'},
    {id:'2C', path:'M470,225 L600,240 L600,255 L470,245 Z', type:'Residential', area:1.8, status:'Available'}
  ],
  node3:[
    {id:'3A', path:'M800,160 L940,160 L930,230 L810,220 Z', type:'Hospitality', area:2.2, status:'Available'},
    {id:'3B', path:'M950,160 L1040,170 L1030,250 L940,240 Z', type:'Retail', area:2.0, status:'Available'}
  ],
  node4:[
    {id:'4A', path:'M240,400 L360,395 L360,470 L250,480 Z', type:'Educational', area:1.4, status:'Available'},
    {id:'4B', path:'M370,392 L500,388 L510,520 L380,520 Z', type:'Residential', area:4.6, status:'Available'},
    {id:'4C', path:'M240,490 L520,480 L525,560 L250,565 Z', type:'Recreational', area:3.0, status:'Available'}
  ],
  node5:[
    {id:'5A', path:'M720,395 L830,400 L820,500 L730,495 Z', type:'Mixed', area:2.8, status:'Available'},
    {id:'5B', path:'M835,402 L980,410 L970,520 L830,510 Z', type:'Health', area:3.2, status:'Available'},
    {id:'5C', path:'M740,520 L1040,540 L1035,600 L750,585 Z', type:'Infrastructure', area:2.1, status:'N/A'}
  ]
};

/* ------------------------------ Setup refs -------------------------------- */
const TYPE_COLORS = {
  Residential:'var(--res)', Retail:'var(--ret)', Office:'var(--off)', Industrial:'var(--ind)',
  Hospitality:'var(--hos)', Educational:'var(--edu)', Health:'var(--hlth)', Recreational:'var(--rec)',
  Mixed:'var(--mix)', Infrastructure:'var(--infra)'
};
const TYPE_CLASS = Object.fromEntries(Object.keys(TYPE_COLORS).map(k=>[k,'c-'+k]));

const map = document.getElementById('map');
const stage = document.getElementById('stage');
const nodeLayer = document.getElementById('nodeLayer');
const parcelLayer = document.getElementById('parcelLayer');
const nodeList = document.getElementById('nodeList');
const parcelList = document.getElementById('parcelList');
const tooltip = document.getElementById('tooltip');
const popover = document.getElementById('popover');
const statusEl = document.getElementById('status');
const counter = document.getElementById('counter');
const summaryBottom = document.getElementById('summaryBottom');
const nodeTitle = document.getElementById('nodeTitle');

const backBtn = document.getElementById('backBtn');
const zoomInBtn = document.getElementById('zoomInBtn');
const zoomOutBtn = document.getElementById('zoomOutBtn');
const resetBtn = document.getElementById('resetBtn');
const legend = document.getElementById('legend');
const clearType = document.getElementById('clearType');

let currentNode = null;
let currentType = null;
let t = {x:0,y:0,scale:1};

/* ------------------------------- Legend UI -------------------------------- */
Object.entries(TYPE_COLORS).forEach(([label,color])=>{
  const wrap = document.createElement('label'); wrap.className='chip';
  wrap.innerHTML = `<input type="radio" name="type" value="${label}"><span class="dot" style="background:${color}"></span>${label}`;
  wrap.querySelector('input').addEventListener('change',()=>setType(label));
  legend.appendChild(wrap);
});
clearType.addEventListener('click', ()=>setType(null));

/* ------------------------------ Utilities --------------------------------- */
function elem(tag, attrs={}, text){
  const e = document.createElementNS('http://www.w3.org/2000/svg', tag);
  Object.entries(attrs).forEach(([k,v])=>e.setAttribute(k,v));
  if(text) e.appendChild(document.createTextNode(text));
  return e;
}
function centroid(pathD){
  const p = elem('path',{d:pathD}); stage.appendChild(p);
  const bb = p.getBBox(); p.remove();
  return {x: bb.x + bb.width/2, y: bb.y + bb.height/2};
}
function svgToClient(x,y){
  const pt = map.createSVGPoint(); pt.x=x; pt.y=y;
  const screen = pt.matrixTransform(stage.getCTM()).matrixTransform(map.getScreenCTM());
  return {x:screen.x, y:screen.y};
}
function clamp(v,min,max){ return Math.max(min, Math.min(max,v)); }
function unionBBox(bbs){
  const xs=bbs.map(b=>b.x), ys=bbs.map(b=>b.y), x2s=bbs.map(b=>b.x+b.width), y2s=bbs.map(b=>b.y+b.height);
  const x=Math.min(...xs), y=Math.min(...ys), x2=Math.max(...x2s), y2=Math.max(...y2s);
  return {x, y, width:x2-x, height:y2-y};
}

/* --------------------------- Tooltip & Popover ---------------------------- */
function showTooltipAt(x,y,html){
  tooltip.innerHTML = html;
  tooltip.classList.remove('hidden');
  const r = tooltip.getBoundingClientRect();
  let left = x + 12, top = y + 12, m = 8;
  if(left + r.width > innerWidth - m) left = innerWidth - r.width - m;
  if(top + r.height > innerHeight - m) top = innerHeight - r.height - m;
  tooltip.style.left = left + 'px';
  tooltip.style.top = top + 'px';
}
function hideTooltip(){ tooltip.classList.add('hidden'); }

function showPopoverAt(x,y,html){
  popover.innerHTML = html;
  popover.classList.remove('hidden');
  const r = popover.getBoundingClientRect();
  let left = x + 12, top = y + 12, m = 8;
  if(left + r.width > innerWidth - m) left = innerWidth - r.width - m;
  if(top + r.height > innerHeight - m) top = innerHeight - r.height - m;
  if(left < m) left = m; if(top < m) top = m;
  popover.style.left = left + 'px';
  popover.style.top = top + 'px';
}
function hidePopover(){ popover.classList.add('hidden'); }

/* ---- Popover follow helpers (for animating while map centers on parcel) --- */
let activePopover = { followEl: null };
function setPopoverContent(html){
  popover.innerHTML = html;
  popover.classList.remove('hidden');
}
function positionPopoverAtClient(x, y){
  const r = popover.getBoundingClientRect();
  let left = x + 12, top = y + 12, m = 8;
  if(left + r.width > innerWidth - m) left = innerWidth - r.width - m;
  if(top + r.height > innerHeight - m) top = innerHeight - r.height - m;
  if(left < m) left = m; if(top < m) top = m;
  popover.style.left = left + 'px';
  popover.style.top = top + 'px';
}
function positionPopoverForElement(el, anchor = 'top-center'){
  const bb = el.getBBox();
  let ax = bb.x + bb.width/2;
  let ay = (anchor === 'top-center') ? bb.y : (bb.y + bb.height/2);
  const pt = svgToClient(ax, ay);
  positionPopoverAtClient(pt.x, pt.y);
}
function startPopoverFollow(el){ activePopover.followEl = el; }
function stopPopoverFollow(){ activePopover.followEl = null; }

window.addEventListener('pointerdown', e=>{
  if(!popover.contains(e.target)) hidePopover();
});

/* ------------------------------ Zoom & Pan -------------------------------- */
function applyTransform(){ stage.setAttribute('transform', `translate(${t.x},${t.y}) scale(${t.scale})`); }
function animateTo(target, ms = 280, onUpdate = null, onDone = null){
  const start = {...t}; const dtX = target.x - start.x, dtY = target.y - start.y, dtS = target.scale - start.scale;
  const t0 = performance.now();
  function step(now){
    const p = Math.min(Math.max((now - t0)/ms, 0), 1);
    const ease = p < .5 ? 2*p*p : 1 - Math.pow(-2*p+2,2)/2; // easeInOutQuad
    t = { x: start.x + dtX*ease, y: start.y + dtY*ease, scale: start.scale + dtS*ease };
    applyTransform();
    if (onUpdate) onUpdate(ease);
    if (p < 1) requestAnimationFrame(step);
    else if (onDone) onDone();
  }
  requestAnimationFrame(step);
}
function zoomToBBox(bb, padding = 24, followEl = null){
  const svgW=1200, svgH=720;
  const scale = Math.min(svgW/(bb.width+padding*2), svgH/(bb.height+padding*2));
  const cx = bb.x + bb.width/2, cy = bb.y + bb.height/2;
  const tx = svgW/2 - scale*cx, ty = svgH/2 - scale*cy;

  if (followEl) startPopoverFollow(followEl);

  animateTo({x:tx,y:ty,scale}, 320,
    () => { if (activePopover.followEl) positionPopoverForElement(activePopover.followEl, 'top-center'); },
    () => { stopPopoverFollow(); }
  );
}
function zoomBy(factor, centerX=600, centerY=360){
  const newScale = Math.max(0.4, Math.min(12, t.scale*factor));
  t.x = centerX - (centerX - t.x) * (newScale / t.scale);
  t.y = centerY - (centerY - t.y) * (newScale / t.scale);
  t.scale = newScale; applyTransform();
}
zoomInBtn.addEventListener('click', ()=>zoomBy(1.25));
zoomOutBtn.addEventListener('click', ()=>zoomBy(0.8));
resetBtn.addEventListener('click', ()=>animateTo({x:0,y:0,scale:1}));

// Wheel zoom (pointer-centered)
map.addEventListener('wheel', (e)=>{
  e.preventDefault();
  const rect = map.getBoundingClientRect();
  const cx = e.clientX - rect.left, cy = e.clientY - rect.top;
  zoomBy(e.deltaY<0?1.1:0.9, cx, cy);
}, {passive:false});

// ---------- Pan only when clicking the BACKGROUND ----------
let dragging=false, last={x:0,y:0};
map.addEventListener('pointerdown', (e)=>{
  const isBackground = (e.target === map || e.target.tagName === 'rect');
  if(!isBackground) return;              // let node/parcel clicks work!
  dragging=true;
  last={x:e.clientX, y:e.clientY};
  map.setPointerCapture(e.pointerId);
});
map.addEventListener('pointermove', (e)=>{
  if(!dragging) return;
  const dx = e.clientX - last.x, dy = e.clientY - last.y;
  last = {x:e.clientX, y:e.clientY};
  t.x += dx; t.y += dy; applyTransform();
});
map.addEventListener('pointerup', (e)=>{
  if(dragging) map.releasePointerCapture(e.pointerId);
  dragging=false;
});

/* ------------------------------- Rendering -------------------------------- */
function labelTopCenterClient(pathD){
  const p = elem('path',{d:pathD}); stage.appendChild(p);
  const bb = p.getBBox(); p.remove();
  return svgToClient(bb.x+bb.width/2, bb.y); // top-center
}

function drawNodes(){
  nodeLayer.innerHTML='';
  NODES.forEach(n=>{
    const g = elem('g',{class:'nodeGroup'});
    const path = elem('path',{d:n.path,class:'node',tabindex:0});
    // hover (mouse position) + CLICK to enter detail
    path.addEventListener('pointermove', e=>{
      const extra = currentType ? `<br><small>${countTypeInNode(n.id,currentType)} ${currentType} available</small>` : '';
      showTooltipAt(e.clientX, e.clientY, `<b>${n.name}</b><br><small>Area: ${n.info.area} ha • Parcels: ${n.info.parcels}</small>${extra}`);
    });
    path.addEventListener('pointerleave', hideTooltip);
    path.addEventListener('click', ()=>enterNode(n.id));   // CLICK

    g.appendChild(path);

    const c = centroid(n.path);
    const label = elem('text',{x:c.x,y:c.y,'text-anchor':'middle','dominant-baseline':'middle'}, n.name);
    label.addEventListener('pointermove', ()=>{
      const pt = labelTopCenterClient(n.path);
      const extra = currentType ? `<br><small>${countTypeInNode(n.id,currentType)} ${currentType} available</small>` : '';
      showTooltipAt(pt.x, pt.y, `<b>${n.name}</b><br><small>Area: ${n.info.area} ha • Parcels: ${n.info.parcels}</small>${extra}`);
    });
    label.addEventListener('pointerleave', hideTooltip);
    label.addEventListener('click', ()=>enterNode(n.id));  // CLICK
    g.appendChild(label);

    nodeLayer.appendChild(g);
  });
}

function drawParcelsOverview(){
  parcelLayer.innerHTML='';
  if(!currentType) return;
  Object.entries(PARCELS).forEach(([nodeId,list])=>{
    list.filter(p=>p.type===currentType).forEach(p=>{
      const path = elem('path',{d:p.path,class:`parcel ${TYPE_CLASS[p.type]}`});
      path.setAttribute('fill-opacity','0.75');
      path.addEventListener('pointermove', e=>{
        showTooltipAt(e.clientX, e.clientY, `<b>Parcel ${p.id} (${nodeId.toUpperCase()})</b><br><small>${p.type} • ${p.area.toFixed(1)} ha</small>`);
      });
      path.addEventListener('pointerleave', hideTooltip);
      parcelLayer.appendChild(path);
    });
  });
}

/* ------------------------------- Sidebar ---------------------------------- */
function buildNodeList(){
  nodeList.innerHTML='';
  NODES.forEach(n=>{
    const li = document.createElement('li');
    const btn = document.createElement('button'); btn.className='btn'; btn.textContent=n.name;
    btn.addEventListener('mouseenter', ()=>{
      const pt = labelTopCenterClient(n.path);
      const extra = currentType ? `<br><small>${countTypeInNode(n.id,currentType)} ${currentType} available</small>` : '';
      showTooltipAt(pt.x, pt.y, `<b>${n.name}</b><br><small>Area: ${n.info.area} ha • Parcels: ${n.info.parcels}</small>${extra}`);
      nodeLayer.querySelectorAll('path').forEach(p=>p.classList.remove('is-hot'));
      const nodePath = [...nodeLayer.querySelectorAll('path')].find(p=>p.getAttribute('d')===n.path);
      if(nodePath) nodePath.classList.add('is-hot');
    });
    btn.addEventListener('mouseleave', ()=>{ hideTooltip(); nodeLayer.querySelectorAll('path').forEach(p=>p.classList.remove('is-hot')); });
    btn.addEventListener('click', ()=>enterNode(n.id)); // sidebar click → detail
    li.appendChild(btn); nodeList.appendChild(li);
  });
}

function buildParcelList(){
  parcelList.innerHTML='';
  if(!currentNode) return;

  const list = PARCELS[currentNode] || [];
  list.forEach(p=>{
    const li = document.createElement('li');
    const btn = document.createElement('button');
    btn.className='btn';
    btn.style.width='100%';
    btn.style.textAlign='left';
    btn.textContent = `Parcel ${p.id} — ${p.type}`;

    // Highlight matches (filter + Available)
    const isMatch = !!currentType && p.type === currentType && (p.status || '').toLowerCase() === 'available';
    if (currentType) {
      if (isMatch) {
        btn.classList.add('match');
        btn.style.background = TYPE_COLORS[p.type] || '#334155';
        btn.style.color = '#0b0f14';
      } else {
        btn.classList.add('dim');
      }
    } else {
      btn.classList.remove('match','dim');
      btn.style.background = '';
      btn.style.color = '';
    }

    btn.addEventListener('mouseenter', ()=>{
      const tmp = elem('path',{d:p.path}); stage.appendChild(tmp); const bb = tmp.getBBox(); tmp.remove();
      const pt = svgToClient(bb.x+bb.width/2, bb.y);
      showTooltipAt(pt.x, pt.y, `<b>Parcel ${p.id}</b><br><small>${p.type} • ${p.area.toFixed(1)} ha</small>`);
    });
    btn.addEventListener('mouseleave', hideTooltip);

    btn.addEventListener('click', ()=>{
      const el = [...parcelLayer.querySelectorAll('path')].find(q => q.getAttribute('d') === p.path);
      if(el){
        openParcelPanel({ currentTarget: el }, p, currentNode); // show instantly
        zoomToBBox(el.getBBox(), 24, el);                      // follow while centering
      }
    });

    li.appendChild(btn);
    parcelList.appendChild(li);
  });
}

/* ----------------------------- Interactions -------------------------------- */
function countTypeInNode(nodeId, type){
  return (PARCELS[nodeId]||[]).filter(p=>p.type===type).length;
}
function setType(tLabel){
  currentType = tLabel;
  statusEl.textContent = tLabel ? `Filtering: ${tLabel}` : 'No filter';
  updateSummary();
  redraw();
  buildParcelList(); // refresh list colors if already in node view
}

// Open parcel detail popover (follow while animating)
function openParcelPanel(evt, p, nodeId){
  const el = evt.currentTarget;
  setPopoverContent(`
    <h3 style="margin:0 0 6px">Parcel ${p.id} — ${p.type}</h3>
    <div><b>Area:</b> ${p.area.toFixed(1)} ha</div>
    <div><b>Status:</b> ${p.status||'—'}</div>
    <div><b>Utilities:</b> Power, Water (demo)</div>
    <div><b>Zoning:</b> ${p.type} (demo)</div>
    <div style="display:flex;gap:8px;margin-top:8px">
      <button class="btn">Download PDF</button>
      <button class="btn">View Development Potential</button>
    </div>
  `);
  positionPopoverForElement(el, 'top-center'); // show now at current pos
  startPopoverFollow(el);                      // start following (zoomToBBox keeps updating)
}

function enterNode(id){
  currentNode = id;
  hideTooltip(); hidePopover(); stopPopoverFollow();

  nodeLayer.innerHTML='';  // hide 5 nodes in detail view
  nodeTitle.classList.remove('hidden');
  nodeTitle.textContent = `${NODES.find(n=>n.id===id).name} — Parcels`;

  parcelLayer.innerHTML='';
  const list = PARCELS[id]||[];
  list.forEach(p=>{
    const path = elem('path',{d:p.path,class:`parcel ${TYPE_CLASS[p.type]}`});
    path.style.opacity = currentType && p.type!==currentType ? .15 : .95;

    path.addEventListener('pointermove', e=>{
      showTooltipAt(e.clientX, e.clientY, `<b>Parcel ${p.id}</b><br><small>${p.type} • ${p.area.toFixed(1)} ha</small>`);
    });
    path.addEventListener('pointerleave', hideTooltip);

    path.addEventListener('click', e=>{
      e.stopPropagation();
      openParcelPanel(e, p, id);                // show instantly
      zoomToBBox(path.getBBox(), 24, path);     // then follow while centering
    });

    parcelLayer.appendChild(path);
  });

  buildParcelList();

  // Fit & center node (union of its parcels)
  if (list.length){
    const tmp = list.map(p=>{ const el = elem('path',{d:p.path}); stage.appendChild(el); const bb = el.getBBox(); el.remove(); return bb; });
    const u = unionBBox(tmp);
    zoomToBBox(u, 36);
  } else {
    animateTo({x:0,y:0,scale:1});
  }

  summaryBottom.classList.add('hidden');
}
backBtn.addEventListener('click', ()=>{
  currentNode = null; hideTooltip(); hidePopover(); stopPopoverFollow();
  nodeTitle.classList.add('hidden');
  parcelLayer.innerHTML='';
  drawNodes(); buildParcelList(); updateSummary();
  animateTo({x:0,y:0,scale:1});
});

// Close tooltip/popover when clicking empty map
map.addEventListener('click', (e)=>{
  if(e.target === map || e.target.tagName === 'rect'){ hideTooltip(); hidePopover(); stopPopoverFollow(); }
});

// Esc leaves node view
window.addEventListener('keydown', e=>{ if(e.key==='Escape' && currentNode){ backBtn.click(); } });

/* --------------------------- Summary & Counter ----------------------------- */
function getStats(){
  let list = currentNode ? (PARCELS[currentNode]||[]) : Object.values(PARCELS).flat();
  if(currentType) list = list.filter(p=>p.type===currentType);
  const area = list.reduce((s,p)=>s+(p.area||0),0);
  return {count:list.length, area};
}
function updateSummary(){
  const stats = getStats();
  const title = currentNode ? `${NODES.find(n=>n.id===currentNode).name}` : 'Summary — Overview';
  const ttype = currentType || 'All Types';

  if(!currentNode){
    summaryBottom.classList.remove('hidden');
    summaryBottom.innerHTML = `<b>${title}</b> · Type: ${ttype} · Parcels: ${stats.count} · Total Area: ${stats.area.toFixed(1)} ha`;
  } else {
    summaryBottom.classList.add('hidden');
  }

  if(currentType){
    counter.textContent = `${stats.count} ${currentType} Parcels Available`;
    counter.classList.remove('hidden');
  } else {
    counter.classList.add('hidden');
  }
}

/* --------------------------------- Boot ----------------------------------- */
function redraw(){
  if(currentNode) enterNode(currentNode);
  else { drawNodes(); drawParcelsOverview(); }
}
(function build(){
  // legend chips built above
  buildNodeList();
  drawNodes();
  drawParcelsOverview();
  updateSummary();
})();
</script>
</body>
</html>
